// SPDX-License-Identifier: AGPL-3.0-or-later
pragma ever-solidity >= 0.66.0;

import "./interfaces/round/IRound.tsol";
import "./interfaces/board/IBoard.tsol";
import "./libraries/Utils.tsol";
import "./libraries/Gas.tsol";
import "./libraries/Navigation.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "./abstracts/board/RoundConfigurationStorage.tsol";
import "./abstracts/board/BoardStorage.tsol";
import "./abstracts/common/Cashback.tsol";
import "./interfaces/board/IJackpot.tsol";

contract Round is IRound, Cashback, BoardStorage {
    uint128 private constant MIN_PLAYERS = 2;                                //  Minimum number of players to attend the game

    //  Basic information
    uint64      public  id;                 //  From initData
    address     public  boardAddress;       //  From initData

    //  Game flow statuses
    RoundStatus public  status = RoundStatus.NotStarted;
    address     public  winner = address(0);

    //  General settings
    uint16      public  maxPlayers;
    bool        public  giveUpAllowed;

    //  Timings
    uint64              public  validUntil;
    uint64              public  roundDuration;
    uint64              public  moveDuration;
    optional(uint64)    public  autoStartTimestamp;

    //  Treasury settings
    uint128             public  entranceFee;
    uint128             public  prizeFund;
    bool                public  prizeClaimed = false;
    uint128             public  rake;
    uint8               public  rakeToJackpotRate;
    RoundTreasury               treasury;

    //  Round metadata
    address[]                          roundPlayers;  // List of players in a round
    Move[] public                      roundMoves;    // Latest round move steps
    mapping(address => uint8)          playerCell;    // Location of player on current map
    //mapping(uint8 => uint48)           cells;         // Contains location of portals on map
    mapping(address => uint128)        remainingEntranceFees;   //  Contains info about entrance fees per player for redeem case

    //  Treasury
    //BoardTreasury boardTreasury; // Board locked balance

    constructor() public {
        //  Can be deployed only via platform
        revert(BaseErrorCodes.NOT_ALLOWED);
    }

    //  By default, rounds are not upgradeable
    //  This function call happens only once after deployment via platform
    function onCodeUpgrade(TvmCell data) private {
        tvm.resetStorage();
        tvm.rawReserve(Gas.CONTRACT_MIN_BALANCE, 0);

        TvmSlice dataSlices = data.toSlice();
        (address _board, , address _sendGasTo, ) = dataSlices.decode(
            address,    //  Board address
            uint8,      //  Platform version, unused
            address,    //  Where to return remainder of gas fees
            TvmCell     //  Platform code, unused
        );

        boardAddress = _board;

        TvmCell initData = dataSlices.loadRef();
        (id) = abi.decode(initData, (uint64));

        TvmCell constructorParams = dataSlices.loadRef();

        (
            Board   _boardSize,
            uint48[] _redBeams,
            uint48[] _blueBeams,
            mapping(uint8 => uint48) _cells,
            uint16  _maxPlayers,
            bool    _giveUpAllowed,
            uint64  _roundDuration,
            uint64  _moveDuration,
            optional(uint64) _autoStartTimestamp,
            uint128 _entryStake,
            uint128 _prizeFund,
            uint128 _rake,
            uint8   _rakeToJackpotRate
        ) = abi.decode(
            constructorParams,
            (Board, uint48[], uint48[], mapping(uint8 => uint48), uint16, bool, uint64, uint64, optional(uint64), uint128, uint128, uint128, uint8)
        );

        board = _boardSize;
        redBeams = _redBeams;
        blueBeams = _blueBeams;
        cells = _cells;
        maxPlayers = _maxPlayers;
        giveUpAllowed = _giveUpAllowed;
        roundDuration = _roundDuration;
        moveDuration = _moveDuration;
        if(_autoStartTimestamp.hasValue()) {
            autoStartTimestamp = Utils._getTimestamp() + _autoStartTimestamp.get();
        }
        entranceFee = _entryStake;
        prizeFund = _prizeFund;
        rake = _rake;
        rakeToJackpotRate = _rakeToJackpotRate;

        _sendGasTo.transfer({value: 0, bounce: false, flag: MsgFlag.ALL_NOT_RESERVED});
    }

    function getLatestMove() external view responsible override returns (optional(Move) move) {
        if(roundMoves.length == 0) return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} null;
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} (roundMoves[roundMoves.length - 1]);
    }

/*
    function getRound(uint64 roundId) external view responsible override returns (optional(Round) round) {
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} rounds.fetch(roundId);
    }
*/

    function join(CallMetadata meta) external override {
        tvm.rawReserve(address(this).balance - msg.value + Gas.TX_STORAGE_FEE, 0);

        Utils.requireWithCashback(msg.sender != boardAddress, meta.returnGasTo, BaseErrorCodes.NOT_ALLOWED);
        Utils.requireWithCashback(roundPlayers.length < maxPlayers, meta.returnGasTo, BaseErrorCodes.NOT_ALLOWED);

        address player = meta.returnGasTo;

        //  Check that player hasn't joined already
        for(address p : roundPlayers) {
            Utils.requireWithCashback(p != player, player, BaseErrorCodes.ITEM_EXISTS);
        }

        //  In case there is an entrance fee, try to charge it
        if(entranceFee > 0) {
            //  Increase the counter for entry stakes
            treasury.entranceFee += entranceFee;
            //  Reserve the amount to check if the value of message is sufficient
            tvm.rawReserve(entranceFee, 0);
        }

        //  Initialized player position
        playerCell[player] = 0;
        roundPlayers.push(player);

        //  Update round status
        _updateRoundStatus();

        emit RoundJoined(address(this), id, player);

        //  Notify the board that the player has joined the round to update indices
        IBoard(boardAddress).onPlayerJoined{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED,
            bounce: false
        }(meta);
    }

    /**
        Rolls a dice and makes a move on generated board
    */
    function roll() external override {
        //tvm.rawReserve(address(this).balance - msg.value + Gas.TX_STORAGE_FEE, 0);  //  Reserve everything except the message value less storage fee and rake value

        address player = msg.sender;

        //  Check if the round is linked to the player
        require(_inRound(player), BaseErrorCodes.PLAYER_NOT_FOUND_IN_ROUND);

        //  Check if player was put on the board
        require(playerCell.exists(player), BaseErrorCodes.PLAYER_NOT_FOUND_ON_BOARD);

        //  Refresh the round status
        _updateRoundStatus();

        tvm.rawReserve(Gas.TX_STORAGE_FEE, 4);  //  Reserve the original balance before msg.value plus storage fee

        //  Check that the round is not finished or expired before
        require(status != RoundStatus.NotStarted, BaseErrorCodes.TOO_EARLY);
        require(status != RoundStatus.Finished, BaseErrorCodes.FINISHED);
        require(status != RoundStatus.Expired, BaseErrorCodes.TOO_LATE);

        //  Take rake and jackpot
        if(rake > 0) {
            IJackpot(boardAddress).onJackpotAccrued{
                value: rake + Gas.JACKPOT_ACCRUAL_FEE,
                bounce: false
            }(
                CallMetadata(id, msg.sender),
                rake,
                rakeToJackpotRate
            );
        }

        //  Contains move metadata and players' steps
        Move        move;

        //  Empty storage of players' steps to initialize a new move
        mapping(address => uint48[]) playerSteps;

        //  Steps of current player
        uint48[]    steps;

        //  Current timestamp
        uint64      timestamp = Utils._getTimestamp();

        if(roundMoves.length > 0) {
            //  If any player has moved already in this round
            //  Take the previously saved move data
            move = roundMoves[roundMoves.length - 1];

            if(
                (move.expiresAt < timestamp) ||                   //  If move has expired
                (move.playerSteps.keys().length == maxPlayers)    //  or all players have moved
            ) {
                move = Move(timestamp + moveDuration, playerSteps);
                roundMoves.push(move);  //  Push a new move to update the storage index
            }
        } else {
            move = Move(timestamp + moveDuration, playerSteps);
            roundMoves.push(move);      //  Push a new move to update the storage index
        }

        //  Check that player hasn't moved yet
        require(!move.playerSteps.exists(player), BaseErrorCodes.ALREADY_MOVED);

        //  Initialize empty steps container
        move.playerSteps[player] = steps;

        //  Roll the dice
        rnd.shuffle();
        uint8 diceVal = rnd.next(6) + 1;

        emit DiceRolled(boardAddress, id, player, diceVal);

        //  Calculate new coordinates
        uint8   curCell = playerCell[player];   //  Current cell the player stands on
        (uint8 x, uint8 y) = Navigation.getXY(curCell, board.columns);
        uint24  prevLocation = Navigation.encodeLocation(curCell, x, y);

        uint8   newCell = curCell + diceVal;    //  The first cell the player moves to
        (x, y) = Navigation.getXY(newCell, board.columns);
        uint24 newLocation = Navigation.encodeLocation(newCell, x, y);

        //  If the player is at the end of the board and got more points than needed, return him back by amount of an overflow
        int8    boardOverflow = int8(board.columns) * int8(board.rows) - int8(newCell);

        //  Current player step
        uint48  step;

        if(boardOverflow < 0) {             //  The player has come out of the board
            //  Calculate location of the last cell
            uint24 lastCellLocation = Navigation.encodeLocation(
                board.columns * board.rows,
                board.columns,
                board.rows
            );

            //  Build path to this location
            step = Navigation.encodePathByLocations(prevLocation, lastCellLocation);

            //  Player first moves to the last cell to step back later
            emit PlayerMoved(
                address(this),
                id,
                player,
                step
            );

            //  Save the first step
            move.playerSteps[player].push(step);

            //  Calculate the next cell the player will move to
            newCell = uint8(int8(board.columns * board.rows) + boardOverflow);
            (x, y) = Navigation.getXY(newCell, board.columns);

            //  Recalculate locations
            newLocation = Navigation.encodeLocation(newCell, x, y); //Location(newCell, _getCoordinate(newCell));
            prevLocation = lastCellLocation;

        } else if (boardOverflow == 0) {    //  The player has got to the final cell
            //  Player has won
            status = RoundStatus.Finished;
            winner = player;
            step = Navigation.encodePathByLocations(prevLocation, newLocation);

            emit PlayerMoved(
                address(this),
                id,
                player,
                step
            );

            move.playerSteps[player].push(step);
            roundMoves[roundMoves.length - 1] = move;
            playerCell[player] = newCell;

            emit RoundFinished(address(this), id, player);
            msg.sender.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});

            return;
        } else {
            //  TODO: Remember what I wanted to put here
        }

        step = Navigation.encodePathByLocations(prevLocation, newLocation);

        emit PlayerMoved(address(this), id, player, step);
        move.playerSteps[player].push(step);
        playerCell[player] = newCell;

        //  Check if player stepped on a portal entrance
        //  Consider only one portal teleportation is possible
        //  Suppose no portal can end on the last cell
        if(cells.exists(newCell)) {
            uint48 path = cells[newCell];

            (
                ,
                uint8 fromX,
                uint8 fromY,
                uint8 toCell,
                uint8 toX,
                uint8 toY
            ) = Navigation.decodePath(path);

            if(fromX == x && fromY == y) {
                prevLocation = newLocation;
                newCell = toCell;
                newLocation = Navigation.encodeLocation(newCell, toX, toY); //Location(_getCell(path.to.x, path.to.y), Coordinate(path.to.x, path.to.y));

                step = Navigation.encodePathByLocations(prevLocation, newLocation);
                move.playerSteps[player].push(step);
                playerCell[player] = newCell;

                emit PlayerMoved(address(this), id, player, step);

                x = toX;
                y = toY;
            }
        }

        roundMoves[roundMoves.length - 1] = move;

/*
        if(rake > 0 && rakeToJackpotRate > 0) {
            //  Register step interval for adaptive jackpot
            registerStepInterval(Utils._getTimestamp());

            //  Draw jackpot
            if(drawJackpot(roundId)) {
                uint128 jackpot = boardTreasury.jackpot;
                if(jackpot > 0) {
                    //  Reset the accumulated jackpot
                    boardTreasury.jackpot = 0;

                    //  Add round treasury if it doesn't exist yet
                    if(!boardTreasury.roundTreasury.exists(roundId)){
                        boardTreasury.roundTreasury[roundId] = RoundTreasury({
                            entranceFee: 0,
                            prize: 0,
                            playerJackpot: emptyMap
                        });
                    }

                    //  Add player jackpot accrual if it doesn't exist yet
                    if(!boardTreasury.roundTreasury[roundId].playerJackpot.exists(player)) {
                        boardTreasury.roundTreasury[roundId].playerJackpot[player] = 0;
                    }

                    //  Increase player's jackpot
                    boardTreasury.roundTreasury[roundId].playerJackpot[player] += jackpot;

                    emit JackpotDrawn(address(this), roundId, player, jackpot);
                }
            }
        }
*/

        msg.sender.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }

    function claim() external override {
        require(status == RoundStatus.Finished, BaseErrorCodes.WRONG_STATE);

        uint128 totalPrize = treasury.prize + treasury.entranceFee;
        require(totalPrize > 0, BaseErrorCodes.NOTHING_TO_PAY);

        require(address(this).balance > (totalPrize + Gas.CONTRACT_MIN_BALANCE/* + msg.value*/), BaseErrorCodes.NOT_ENOUGH_BALANCE);
        require(!prizeClaimed, BaseErrorCodes.FINISHED);

        tvm.rawReserve(Gas.CONTRACT_MIN_BALANCE, 0);

        winner.transfer({value: totalPrize, bounce: false, flag: MsgFlag.SENDER_PAYS_FEES});
        prizeClaimed = true;
        emit PrizeClaimed(address(this), id, winner, totalPrize);

        IJackpot(boardAddress).claimJackpot{
                value: Gas.JACKPOT_CALL_FEE,
                bounce: false
            }(CallMetadata(id, winner));

        msg.sender.transfer({value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false});
    }

    /**
        Allows player to redeem the entranceFee in case the round has expired

        @param  player  Address of the participating player
    */
    function redeem(address player) external override {
        require(status == RoundStatus.Expired, BaseErrorCodes.WRONG_STATE);
        require(remainingEntranceFees.exists(player), BaseErrorCodes.NOT_ALLOWED);
        require(remainingEntranceFees[player] > 0, BaseErrorCodes.NOTHING_TO_PAY);

        player.transfer({value: remainingEntranceFees[player], bounce: false});
        msg.sender.transfer({value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false});
    }

    function getRoundStatus() external view responsible override returns (uint64 _id, RoundStatus _status) {
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} (id, status);
    }

    function updateRoundStatus() external override cashback {
        tvm.rawReserve(address(this).balance - msg.value + Gas.TX_STORAGE_FEE, 0);
        _updateRoundStatus();
    }

    function _updateRoundStatus() internal {
        uint64 timestamp = Utils._getTimestamp();

        //  Check if round has expired
        if(validUntil > 0 && validUntil <= timestamp) {
            status = RoundStatus.Expired;
            tvm.commit();
            return;
        }

        //  Check if round is in final status
        if(status == RoundStatus.Finished || status == RoundStatus.Expired) return;

        //  Check if all players have joined
        if(status == RoundStatus.NotStarted) {
            if(roundPlayers.length < MIN_PLAYERS) return;

            if(roundPlayers.length < maxPlayers) {
                if(autoStartTimestamp.hasValue()) {
                    if(autoStartTimestamp.get() > Utils._getTimestamp()) {
                        return;
                    } else {
                        status = RoundStatus.Ready;
                    }
                }
            } else {
                status = RoundStatus.Ready;
            }

            tvm.commit();
            return;
        }

        //  Set the round validity after the first roll
        if(status == RoundStatus.Ready) {
            //  Check that the prize is sufficient
            if((address(this).balance - msg.value + Gas.TX_STORAGE_FEE) < (treasury.entranceFee + treasury.prize)) return;

            validUntil = roundDuration + Utils._getTimestamp();
            status = RoundStatus.Active;
            tvm.commit();
            return;
        }

        if(status == RoundStatus.Active) {
            uint8 lastCell = board.columns * board.rows;
            for((, uint8 pCell) : playerCell) {
                if(pCell == lastCell) {
                    status = RoundStatus.Finished;
                    tvm.commit();
                    return;
                }
            }
        }
    }

    function _inRound(address player) internal view returns (bool) {
        for(address p : roundPlayers) {
            if(p == player) return true;
        }

        return false;
    }


    /**
        Safely removes the player from a round and resets its environment

        @param  roundId     Round identifier
        @param  player      Player address
    */
    function _removePlayerFromRound(uint64 roundId, address player) internal {
        require(rounds.exists(roundId), BaseErrorCodes.ITEM_NOT_FOUND);
        require(roundPlayers.exists(roundId), BaseErrorCodes.ITEM_NOT_FOUND);

        //  Detach round from player
        if(playerRound.exists(player)) delete playerRound[player];

        //  Detach position on the board from player
        if(playerCell.exists(player)) delete playerCell[player];

        //  Update the list of players
        address[] newPlayerList;

        for(address pl : roundPlayers[roundId]) {
            if(pl != player) newPlayerList.push(pl);
        }

        roundPlayers[roundId] = newPlayerList;

        //  In case the only one player is left in the round, they become winner automatically
        if(newPlayerList.length == 1) {
            rounds[roundId].winner = newPlayerList[0];
            rounds[roundId].status = RoundStatus.Finished;
        }

        //  Fix the number of players in the storage
        rounds[roundId].maxPlayers--;

        //  Check for jackpot payout
        optional(RoundTreasury) rto = treasury.roundTreasury.fetch(roundId);
        if(!rto.hasValue()) return;

        RoundTreasury rt = rto.get();
        if(!rt.playerJackpot.exists(player)) return;

        //  Payout jackpot
        uint128 jackpot = rt.playerJackpot[player];
        if(jackpot > 0) {
            player.transfer({value: jackpot, bounce: true});
            emit JackpotClaimed(address(this), roundId, player, jackpot);
        }

        delete rt.playerJackpot[player];
    }
}
