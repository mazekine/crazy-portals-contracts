// SPDX-License-Identifier: UNLICENSED
pragma ever-solidity >= 0.62.0;

interface IGame {
    struct Coordinate {
        uint16 x;
        uint16 y;
    }

    enum PathType {
        RedBeam, BlueBeam
    }

    struct Path {
        Coordinate from;
        Coordinate to;
        PathType   type_;
    }

    enum RoundStatus {
        NotStarted, Ready, Active, Finished, Expired
    }

    struct Round {
        uint64      id;
        uint64      validUntil;
        uint64      moveDuration;
        RoundStatus status;
        uint16      maxPlayers;
        uint128     entryStake;
        uint128     prizeFund;
        bool        prizeClaimed;
        address     winner;
        uint64      autoStartTimestamp;
    }

    struct Board {
        uint16 columns;
        uint16 rows;
    }

    struct Move {
        uint64    expiresAt;
        mapping(address => Step[]) playerSteps;
    }

    struct Location {
        uint16      cell;
        Coordinate coordinate;
    }

    struct Step {
        Location from;
        Location to;
    }

    struct RoundTreasury {
        uint128 prize;
        uint128 entranceFee;
        mapping(address => uint128) playerJackpot;
    }

    struct BoardTreasury {
        uint128 rakes;
        uint128 jackpot;
        mapping(uint64 => RoundTreasury) roundTreasury;
    }

    event DiceRolled(address player, uint16 dice);
    event PathFound(address player, Path path);
    event BoardGenerated(Board board, Path[] redBeams, Path[] blueBeams);

    event EntryStakeUpdated(address board, uint128 oldValue, uint128 newValue);
    event PrizeFundUpdated(address board, uint128 oldValue, uint128 newValue);
    event MaxRoundTimeMsUpdated(address board, uint64 oldValue, uint64 newValue);
    event MaxMoveTimeMsUpdated(address board, uint64 oldValue, uint64 newValue);
    event RoundAutostartMsUpdated(address board, uint64 oldValue, uint64 newValue);
    event MaxPlayersUpdated(address board, uint16 oldValue, uint16 newValue);

    event RoundCreated(address board, uint64 roundId);
    event RoundJoined(address board, uint64 roundId, address player);
    event PlayerMoved(address board, uint64 round, address player, Location from, Location to);
    event RoundFinished(address board, uint64 roundId, address winner);
    event PrizeClaimed(address board, uint64 roundId, address player);

    function generateBoard(uint seed, uint16 maxRedBeams, uint16 maxBlueBeams) external;
    function getBoard() external view responsible returns (Board board, Path[] redBeams, Path[] blueBeams);
    function roll() external responsible returns (uint16 dice, Coordinate newPosition);
    function claim(uint64 roundId) external;

    function createRound() external responsible returns (Round round);
    function getRound(uint64 roundId) external view responsible returns (optional(Round) round);
    function getRounds(optional(RoundStatus) status) external view responsible returns (Round[] rounds);
    function getRoundLatestMove(uint64 roundId) external view responsible returns (optional(Move) move);
    function joinRound(uint64 roundId) external responsible returns (bool result);

    function setMaxPlayers(uint16 qty) external;
    function setMaxRoundTimeMs(uint64 ms) external;
    function setMaxMoveTimeMs(uint64 ms) external;
    function setPrizeFund(uint128 amount) external;
    function setEntryStake(uint128 amount) external;
    function setAutostartMs(uint64 ms) external;
}
