// SPDX-License-Identifier: UNLICENSED
pragma ever-solidity >= 0.62.0;
//pragma AbiHeader pubkey;

import "./interfaces/IGame.tsol";
import "./abstracts/Ownable.tsol";
import "./abstracts/Cashback.tsol";
import "./libraries/Gas.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";

contract Game is IGame, Ownable, Cashback {
    uint64  public static nonce;

    uint64  private MAX_ROUND_DURATION_MS_DEFAULT = 30 * 60 * 1000; //  30 minutes
    uint64  private MOVE_DURATION_MS_DEFAULT  = 60_000;         //  1 minute

    mapping(uint64 => Round) public rounds;
    uint16  public maxPlayers = 4;
    uint64  public maxRoundDurationMs = MAX_ROUND_DURATION_MS_DEFAULT;
    uint64  public maxMoveDurationMs = MOVE_DURATION_MS_DEFAULT;
    Board   public board;
    Path[]  snakes;
    Path[]  ladders;
    bool    public boardInitialized;
    uint    public seed;
    uint128 public prizeFundPerRound;
    uint128 public entryStake;
    uint16  public maxSnakes;
    uint16  public maxLadders;

    mapping(address => uint64)       playerRound;
    mapping(uint64 => address[])     roundPlayers;
    mapping(uint64 => Move)          roundMoves;
    mapping(address => uint16)        playerCell;
    mapping(uint16 => optional(Path)) cells;

    constructor(address owner, uint16 size) public {
        require((size % 2 == 0) || (size >= 6) || (size <= 16), BaseErrorCodes.NOT_ALLOWED);

        tvm.accept();
        board = Board(size, size);

        _initOwnable(owner);
    }

    function generateBoard(uint _seed, uint16 _maxSnakes, uint16 _maxLadders)
        external
        override
        onlyOwner
        reservable
        cashback
    {
        require(!boardInitialized, BaseErrorCodes.ITEM_EXISTS);
        require(_maxSnakes <= (board.rows - 2), BaseErrorCodes.VALUE_TOO_BIG);
        require(_maxLadders <= (board.rows - 2), BaseErrorCodes.VALUE_TOO_BIG);

        maxSnakes = _maxSnakes;
        maxLadders = _maxLadders;

        seed = _seed;
        rnd.setSeed(seed);
        rnd.shuffle();

        uint16 headCell;
        uint16 tailCell;

        for(uint16 i = 0; i < maxSnakes; i++) {
            Path snake = _getPath(PathType.Snake);
            headCell = _getCell(snake.from.x, snake.from.y);
            tailCell = _getCell(snake.to.x, snake.to.y);
            cells[headCell] = snake;
            cells[tailCell] = snake;
            snakes.push(snake);
        }

        for(uint16 i = 0; i < maxLadders; i++) {
            Path ladder = _getPath(PathType.Ladder);
            tailCell = _getCell(ladder.from.x, ladder.from.y);
            headCell = _getCell(ladder.to.x, ladder.to.y);
            cells[headCell] = ladder;
            cells[tailCell] = ladder;
            ladders.push(ladder);
        }

        boardInitialized = true;

        emit BoardGenerated(board, snakes, ladders);
    }

    function getBoard()
        external
        view
        responsible
        override
    returns (Board _board, Path[] _snakes, Path[] _ladders) {
        return {value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false} (board, snakes, ladders);
    }

    function roll()
        external
        responsible
        override
    returns (uint16 dice, Coordinate newPosition) {
        address player = msg.sender;
        //  Check if the round is linked to the player
        //  TODO: reset rounds after finish
        require(playerRound.exists(player), BaseErrorCodes.NOT_ALLOWED);
        //  Check if player was put on the board
        require(playerCell.exists(player), BaseErrorCodes.ITEM_NOT_FOUND);

        uint64 roundId = playerRound[player];
        //  Check if such round exists
        if(!rounds.exists(roundId)) {
            delete playerRound[player];
            delete playerCell[player];
            revert(BaseErrorCodes.ITEM_NOT_FOUND);
        }

        Round round = rounds[roundId];
        //  Check that the round is not finished
        require(round.status != RoundStatus.Finished, BaseErrorCodes.FINISHED);

        //  Check that the round is not expired
        //  TODO: on join round check that the previous one has finished or expired
        if(round.validUntil <= block.timestamp) {
            rounds[roundId].status = RoundStatus.Expired;
            revert(BaseErrorCodes.TOO_LATE);
        }

        //  Activate round if it's the first step in it
        if(round.status == RoundStatus.Ready) {
            //  Check that prize if available
            //  TODO: freeze the prize per rounds
            require(address(this).balance > (Gas.CONTRACT_MIN_BALANCE + round.prizeFund), BaseErrorCodes.NOT_ENOUGH_BALANCE);

            //  Check that all players have joined
            require(roundPlayers[roundId].length == round.maxPlayers, BaseErrorCodes.NOT_ALLOWED);

            round.status = RoundStatus.Active;
        }

        mapping(address => Step[]) playersMoved;
        Step[]  steps;
        Move    move;

        if(roundMoves.exists(roundId)) {
            //  If any player has moved already in this round
            move = roundMoves.fetch(roundId).get();

            if(
                (move.expiresAt < block.timestamp) ||                   //  If move has expired
                (move.playerSteps.keys().length == round.maxPlayers)    //  or all players have moved
            ) {
                move = Move(block.timestamp + round.moveDuration, playersMoved);
            }
        } else {
            move = Move(block.timestamp + round.moveDuration, playersMoved);
        }

        //  Check that player hasn't moved yet
        for(address _player : move.playerSteps.keys()) {
            require(!(_player == player), BaseErrorCodes.NOT_ALLOWED);
        }

        move.playerSteps[player] = steps;

        //roundMoves[roundId] = move; //  Do I need to leave it here?

        rnd.shuffle();
        uint16 diceVal = rnd.next(6) + 1;   //  TEST: 5

        emit DiceRolled(player, dice);

        Location    curLocation;
        Location    prevLocation;
        uint16      curCell = playerCell[player];  //  TEST: 0
        uint16      newCell = curCell + diceVal;   //  TEST: 5
        int16       boardOverflow = int16(board.columns) * int16(board.rows) - int16(newCell); // TEST: 100 - 5 = 95
        uint16      x;
        uint16      y;

        prevLocation = Location(curCell, _getCoordinate(curCell));  // TEST: {0, {0, 0}}
        curLocation  = Location(newCell, _getCoordinate(newCell));  // TEST: {5, {5, 1}}

        if(boardOverflow < 0) { //  TEST: false
            newCell = uint16(int16(board.columns * board.rows) + boardOverflow);
            curLocation  = Location(newCell, _getCoordinate(newCell));
        } else if (boardOverflow == 0) {    //  TEST: false
            //  Player has won
            rounds[roundId].status = RoundStatus.Finished;
            rounds[roundId].winner = player;
            move.playerSteps[player].push(Step(prevLocation, curLocation));
            roundMoves[roundId] = move;

            emit RoundFinished(address(this), roundId, player);
            return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} (diceVal, _getCoordinate(newCell));
        }

        move.playerSteps[player].push(Step(prevLocation, curLocation));

        x = curLocation.coordinate.x;   //  TEST: 5
        y = curLocation.coordinate.y;   //  TEST: 1

        bool flag;
        while(!flag) {
            (uint16 _x, uint16 _y) = _checkContinuation(player, x, y);
            if(_x == x && _y == y) {
                flag = true;    //  TEST: true
            } else {
                x = _x;
                y = _y;

                prevLocation = curLocation;
                curLocation = Location(_getCell(x, y), Coordinate(x, y));
                move.playerSteps[player].push(Step(prevLocation, curLocation));
                emit PlayerMoved(address(this), roundId, player, prevLocation, curLocation);
            }
        }

        newCell = _getCell(x, y);   //  TEST: 5
        playerCell[player] = newCell;
        roundMoves[roundId] = move;

        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} (diceVal, Coordinate(x, y));
    }

    function getRoundLatestMove(uint64 roundId) external view responsible override returns (optional(Move) move) {
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} (roundMoves.fetch(roundId));
    }

    function createRound()
        external
        responsible
        override
    returns (Round round) {
        require(boardInitialized, BaseErrorCodes.TOO_EARLY);

        uint64 roundId = block.timestamp;
        require(!rounds.exists(roundId), BaseErrorCodes.ITEM_EXISTS);

        Round newRound = Round(
            roundId,
            roundId + maxRoundDurationMs,
            maxMoveDurationMs,
            RoundStatus.NotStarted,
            maxPlayers,
            entryStake,
            prizeFundPerRound,
            false,
            address(0)
        );

        rounds[roundId] = newRound;

        emit RoundCreated(address(this), roundId);

        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} newRound;
    }

    function getRound(uint64 roundId) external view responsible override returns (optional(Round) round) {
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} rounds.fetch(roundId);
    }

    function getRounds(optional(RoundStatus) status) external view responsible override returns (Round[] _rounds) {
        if(!status.hasValue()) return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} rounds.values();

        Round[] result;
        RoundStatus rs = status.get();
        for(Round round : rounds.values()) {
            if(round.status == rs) result.push(round);
        }

        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} result;
    }

    function setMaxPlayers(uint16 qty) external override onlyOwner reservable cashback {
        uint16 oldVal = maxPlayers;
        maxPlayers = qty;

        emit MaxPlayersUpdated(address(this), oldVal, maxPlayers);
    }

    function setMaxRoundTimeMs(uint64 ms) external override onlyOwner reservable cashback {
        uint64 oldVal = maxRoundDurationMs;
        maxRoundDurationMs = ms;

        emit MaxRoundTimeMsUpdated(address(this), oldVal, maxRoundDurationMs);
    }

    function setPrizeFund(uint128 amount) external override onlyOwner reservable cashback {
        uint128 oldVal = prizeFundPerRound;
        prizeFundPerRound = amount;

        emit PrizeFundUpdated(address(this), oldVal, prizeFundPerRound);
    }

    function setEntryStake(uint128 amount) external override onlyOwner reservable cashback {
        uint128 oldVal = entryStake;
        entryStake = amount;

        emit EntryStakeUpdated(address(this), oldVal, entryStake);
    }

    function joinRound(uint64 roundId)
        external
        responsible
        override
    returns (bool result) {
        require(rounds.exists(roundId), BaseErrorCodes.ITEM_NOT_FOUND);
        require(roundPlayers[roundId].length < rounds[roundId].maxPlayers, BaseErrorCodes.NOT_ALLOWED);

        address player = msg.sender;
        for(address _player : roundPlayers[roundId]) {
            require(_player != player, BaseErrorCodes.NOTHING_CHANGED);
        }

        if(playerRound.exists(player)) {
            require(playerRound[player] != roundId, BaseErrorCodes.NOTHING_CHANGED);
            uint64 oldRound = playerRound[player];

            require(rounds[oldRound].status == RoundStatus.Finished || rounds[oldRound].status == RoundStatus.Expired, BaseErrorCodes.NOT_ALLOWED);
        }

        playerRound[player] = roundId;
        roundPlayers[roundId].push(player);
        playerCell[player] = 0;

        if(roundPlayers[roundId].length == rounds[roundId].maxPlayers) rounds[roundId].status = RoundStatus.Ready;

        emit RoundJoined(address(this), roundId, player);

        return {value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS} (true);
    }

    function claim(uint64 roundId) external override /*reservable cashback*/ {
        require(rounds.exists(roundId), BaseErrorCodes.ITEM_NOT_FOUND);
        Round round = rounds[roundId];

        require(round.status == RoundStatus.Finished, BaseErrorCodes.WRONG_STATE);
        require(round.winner == msg.sender, BaseErrorCodes.NOT_ALLOWED);
        require(address(this).balance > (Gas.CONTRACT_MIN_BALANCE + round.prizeFund), BaseErrorCodes.NOT_ENOUGH_BALANCE);
        require(!round.prizeClaimed, BaseErrorCodes.FINISHED);

        round.winner.transfer({value: round.prizeFund, bounce: false});
        rounds[roundId].prizeClaimed = true;

        emit PrizeClaimed(address(this), roundId, round.winner);
    }

    function _checkContinuation(address player, uint16 x, uint16 y) internal view returns (uint16 _x, uint16 _y) {
        _x = x; //  TEST: 5
        _y = y; //  TEST: 1

        for(Path snake : snakes) {
            if(snake.from.x == x && snake.from.y == y) {
                _x = snake.to.x;
                _y = snake.to.y;

                emit PathFound(player, snake);
            }
        }

        for(Path ladder : ladders) {
            if(ladder.from.x == x && ladder.from.y == y) {
                _x = ladder.to.x;
                _y = ladder.to.y;

                emit PathFound(player, ladder);
            }
        }

        return (_x, _y);
    }

    function _getCell(uint16 x, uint16 y) private view returns (uint16 cell) {
        bool rtl = (y % 2 == 0);
        if (rtl) x = board.columns - x + 1;
        return ((y - 1) * board.columns + x);
    }

    function _getCoordinate(uint16 cell) private view returns (Coordinate) {
        if(cell == 0) return Coordinate(0, 0);

        uint16 y = (cell - 1) / board.columns + 1;  //  TEST: (5 - 1) / 10 + 1 = 1
        uint16 x = cell - (y - 1) * board.columns;  //  TEST: 5 - (1 - 1) * 10 = 5

        bool rtl = (y % 2 == 0);    //  TEST: false
        if (rtl) {
            x = board.columns - x + 1;
        }

        return Coordinate(x, y);
    }

    function _getPath(PathType pathType) private view returns (Path path) {
        Coordinate head;
        Coordinate tail;

        uint16 headCell;
        uint16 tailCell;

        bool flag;
        while(!flag) {
            head.x = rnd.next(board.columns) + 1;
            head.y = rnd.next(board.rows - 1) + 2;              //  Head cannot happen on the first row
            headCell = _getCell(head.x, head.y);

            flag =  !(head.y == board.rows && head.x == 1) &&   //  Head cannot be on the final cell
                    !cells[headCell].hasValue();                //  The cell cannot be occupied
        }

        flag = false;
        while(!flag) {
            tail.x = rnd.next(board.columns) + 1;
            tail.y = rnd.next(head.y - 2) + 1;                  //  Tail must be lower than head
            tailCell = _getCell(tail.x, tail.y);
            flag = !cells[tailCell].hasValue();

            if(pathType == PathType.Ladder) {
                flag = flag && !(tailCell == 1);                //  Ladder cannot happen on the first cell
            }
        }

        Path result;
        if(pathType == PathType.Snake) {
            result = Path(head, tail, pathType);
        } else {
            result = Path(tail, head, pathType);
        }

        return result;
    }

    function _checkBoardInitialized() private {
        if((snakes.length == maxSnakes) && (ladders.length == maxLadders)) {
            boardInitialized = true;
            emit BoardGenerated(board, snakes, ladders);
        }
    }

}
