// SPDX-License-Identifier: UNLICENSED
pragma ever-solidity >= 0.62.0;
//pragma AbiHeader pubkey;

import "./interfaces/IGame.tsol";
import "./abstracts/Ownable.tsol";
import "./abstracts/Cashback.tsol";
import "./libraries/Gas.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";

contract Game is IGame, Ownable, Cashback {
    uint64  public static nonce;

    //  Default configurations
    uint64  private MAX_ROUND_DURATION_MS_DEFAULT = 30 * 60 * 1000; //  30 minutes
    uint64  private MOVE_DURATION_MS_DEFAULT      =  1 * 60 * 1000; //  1 minute
    uint64  private ROUND_AUTOSTART_MS_DEFAULT    =  5 * 60 * 1000; //  5 minutes
    uint128 private TX_STORAGE_FEE = 0.05 ever;                     //  Default estimation of storage fee
    uint128 private RAKE = 0.01 ever;                               //  Default rake rate for a game
    uint128 private PRIZE_FUND_PER_ROUND_DEFAULT = 1 ever;          //  Default prize fund per game

    //  Board settings
    uint    public seed;                                                // Map seed used to generate the map
    uint16  public blueBeamsNumber;                                     // Number of blue portals to generate on board
    uint16  public redBeamsNumber;                                      // Number of red portals to generate on board
    bool    public boardInitialized;                                    // Indicates if the board was generated already
    uint64  public maxRoundDurationMs = MAX_ROUND_DURATION_MS_DEFAULT;  // Maximum round duration in milliseconds
    uint64  public maxMoveDurationMs = MOVE_DURATION_MS_DEFAULT;        // Maximum time for a step within round, in milliseconds
    optional(uint64)  public roundAutostartMs = ROUND_AUTOSTART_MS_DEFAULT;       // The period in milliseconds after creation of the round when it can start
    uint128 public prizeFundPerRound = PRIZE_FUND_PER_ROUND_DEFAULT;    // Prize fund setting per round
    uint16  public maxPlayers = 4;                                      // Number of players in a round
    uint128 public entryStake;                                          // Entry stake setting per round

    //  Configuration storage
    mapping(uint64 => Round) rounds;    //  The list of rounds
    Board   public           board;     //  Board size
    Path[]                   redBeams;  //  Red portals
    Path[]                   blueBeams; //  Blue portals

    //  Rounds metadata
    mapping(address => uint64)        playerRound;   // Active round for player
    mapping(uint64 => address[])      roundPlayers;  // List of players in a round
    mapping(uint64 => Move)           roundMoves;    // Latest round move steps
    mapping(address => uint16)        playerCell;    // Location of player of current map
    mapping(uint16 => optional(Path)) cells;         // Contains location of portals on map

    //  Treasury
    BoardTreasury boardTreasury; // Board locked balance

    /**
        @param  owner   Default owner of the board
        @param  size    Size of the board (must be an even number in range [6; 16])
    */
    constructor(address owner, uint16 size) public {
        require((size % 2 == 0) || (size >= 6) || (size <= 16), BaseErrorCodes.NOT_ALLOWED);

        tvm.accept();
        board = Board(size, size);

        _initOwnable(owner);
    }

    /**
        Generates a new game board. Can be done only once per contract.

        @param  _seed           Random salt to initiate randomizer
        @param  _maxRedBeams    Maximum number of red portals
        @param  _maxBlueBeams   Maximum number of blue portals
    */
    function generateBoard(uint _seed, uint16 _maxRedBeams, uint16 _maxBlueBeams)
        external
        override
        onlyOwner
        reservable
        cashback
    {
        require(!boardInitialized, BaseErrorCodes.ITEM_EXISTS);
        require(_maxRedBeams <= (board.rows - 2), BaseErrorCodes.VALUE_TOO_BIG);
        require(_maxBlueBeams <= (board.rows - 2), BaseErrorCodes.VALUE_TOO_BIG);

        redBeamsNumber = _maxRedBeams;
        blueBeamsNumber = _maxBlueBeams;

        seed = _seed;
        rnd.setSeed(seed);
        rnd.shuffle();

        uint16 headCell;
        uint16 tailCell;

        for(uint16 i = 0; i < redBeamsNumber; i++) {
            Path redBeam = _getPath(PathType.RedBeam);
            headCell = _getCell(redBeam.from.x, redBeam.from.y);
            tailCell = _getCell(redBeam.to.x, redBeam.to.y);
            cells[headCell] = redBeam;
            cells[tailCell] = redBeam;
            redBeams.push(redBeam);
        }

        for(uint16 i = 0; i < blueBeamsNumber; i++) {
            Path blueBeam = _getPath(PathType.BlueBeam);
            tailCell = _getCell(blueBeam.from.x, blueBeam.from.y);
            headCell = _getCell(blueBeam.to.x, blueBeam.to.y);
            cells[headCell] = blueBeam;
            cells[tailCell] = blueBeam;
            blueBeams.push(blueBeam);
        }

        boardInitialized = true;

        emit BoardGenerated(board, redBeams, blueBeams);
    }

    /**
        Configures maximum number of players per round.

        @dev    Affects only future rounds
        @param  qty Number of players
    */
    function setMaxPlayers(uint16 qty) external override onlyOwner reservable cashback {
        uint16 oldVal = maxPlayers;
        maxPlayers = qty;

        emit MaxPlayersUpdated(address(this), oldVal, maxPlayers);
    }

    /**
        Configures round time in milliseconds.
        The round will expire after the specified time passes since the start

        @dev    Affects only future rounds
        @param  ms  Time in milliseconds
    */
    function setMaxRoundTimeMs(uint64 ms) external override onlyOwner reservable cashback {
        uint64 oldVal = maxRoundDurationMs;
        maxRoundDurationMs = ms;

        emit MaxRoundTimeMsUpdated(address(this), oldVal, maxRoundDurationMs);
    }

    /**
        Configures move time in milliseconds.
        Players can make only one step within a move, and this parameter indicates the move expiry interval

        @dev    Affects only future rounds
        @param  ms  Time in milliseconds
    */
    function setMaxMoveTimeMs(uint64 ms) external override onlyOwner reservable cashback {
        uint64 oldVal = maxMoveDurationMs;
        maxMoveDurationMs = ms;

        emit MaxMoveTimeMsUpdated(address(this), oldVal, maxMoveDurationMs);
    }

    /**
        Configures the prize fund for a round.

        @dev    Affects only future rounds
        @param  amount  Amount in nanoevers that can be claimed by the winner
    */
    function setPrizeFund(uint128 amount) external override onlyOwner reservable cashback {
        uint128 oldVal = prizeFundPerRound;
        prizeFundPerRound = amount;

        emit PrizeFundUpdated(address(this), oldVal, prizeFundPerRound);
    }

    /**
        Configures the entry stake paid by players during the round joining

        @dev    Affects only future rounds
        @param  amount  Amount in nanoevers that shall be paid by each participant before the round starts
    */
    function setEntryStake(uint128 amount) external override onlyOwner reservable cashback {
        uint128 oldVal = entryStake;
        entryStake = amount;

        emit EntryStakeUpdated(address(this), oldVal, entryStake);
    }

    /**
        Sets the period in milliseconds after the creation of the round after which it will start even if it hasn't obtained enough players
    */
    function setAutostartMs(optional(uint64) ms) external override onlyOwner reservable cashback {
        uint64 oldVal = roundAutostartMs;
        roundAutostartMs = ms;

        emit RoundAutostartMsUpdated(address(this), oldVal, roundAutostartMs);
    }

    /**
        Creates new round

        @return round   Round metadata
    */
    function createRound()
    external
    responsible
    override
    returns (Round round) {
        require(boardInitialized, BaseErrorCodes.TOO_EARLY);

        uint64 roundId = block.timestamp;
        require(!rounds.exists(roundId), BaseErrorCodes.ITEM_EXISTS);

        Round newRound = Round(
            roundId,
            roundId + maxRoundDurationMs,
            maxMoveDurationMs,
            RoundStatus.NotStarted,
            maxPlayers,
            entryStake,
            prizeFundPerRound,
            false,
            address(0),
            roundId + roundAutostartMs
        );

        rounds[roundId] = newRound;

        emit RoundCreated(address(this), roundId);

        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} newRound;
    }

    /**
        Joins the requesting player to the specified round

        @param      roundId Round identifier
        @return     result  Status of joining
    */
    function joinRound(uint64 roundId)
    external
    responsible
    override
    returns (bool result) {
        tvm.rawReserve(msg.value - TX_STORAGE_FEE, 12); //  Reserve all except message value less storage fee

        require(rounds.exists(roundId), BaseErrorCodes.ITEM_NOT_FOUND);
        require(roundPlayers[roundId].length < rounds[roundId].maxPlayers, BaseErrorCodes.NOT_ALLOWED);

        address player = msg.sender;
        for(address _player : roundPlayers[roundId]) {
            require(_player != player, BaseErrorCodes.NOTHING_CHANGED);
        }

        if(playerRound.exists(player)) {
            require(playerRound[player] != roundId, BaseErrorCodes.NOTHING_CHANGED);
            uint64 oldRound = playerRound[player];

            require(rounds[oldRound].status == RoundStatus.Finished || rounds[oldRound].status == RoundStatus.Expired, BaseErrorCodes.NOT_ALLOWED);
        }

        playerRound[player] = roundId;
        roundPlayers[roundId].push(player);
        playerCell[player] = 0;

        if(roundPlayers[roundId].length == rounds[roundId].maxPlayers) rounds[roundId].status = RoundStatus.Ready;

        emit RoundJoined(address(this), roundId, player);

        return {value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS} (true);
    }

    /**
        Rolls a dice and makes a move on generated board

        @return dice        Value of the received dice
        @return newPosition New location where the player moved after the step
    */
    function roll()
    external
    responsible
    override
    returns (uint16 dice, Coordinate newPosition) {
        require(boardInitialized, BaseErrorCodes.TOO_EARLY);

        tvm.rawReserve(msg.value - TX_STORAGE_FEE - RAKE, 1);  //  Reserve everything except the message value less storage fee and rake value

        address player = msg.sender;

        //  Check if the round is linked to the player
        //  TODO: reset rounds after finish
        require(playerRound.exists(player), BaseErrorCodes.NOT_ALLOWED);

        //  Check if player was put on the board
        require(playerCell.exists(player), BaseErrorCodes.ITEM_NOT_FOUND);

        uint64 roundId = playerRound[player];
        //  Check if such round exists
        if(!rounds.exists(roundId)) {
            delete playerRound[player];
            delete playerCell[player];
            revert(BaseErrorCodes.ITEM_NOT_FOUND);
        }

        Round round = rounds[roundId];
        //  Check that the round is not finished
        require(round.status != RoundStatus.Finished, BaseErrorCodes.FINISHED);

        //  Check that the round is not expired
        //  TODO: on join round check that the previous one has finished or expired
        if(round.validUntil <= block.timestamp) {
            rounds[roundId].status = RoundStatus.Expired;
            tvm.commit();
            revert(BaseErrorCodes.TOO_LATE);
        }

        //  Activate round if it's the first step in it
        if(round.status == RoundStatus.Ready) {
            //  Check that prize if available
            //  TODO: freeze the prize per rounds
            require(address(this).balance > (Gas.CONTRACT_MIN_BALANCE + round.prizeFund), BaseErrorCodes.NOT_ENOUGH_BALANCE);

            //  Check that all players have joined
            require(roundPlayers[roundId].length == round.maxPlayers, BaseErrorCodes.NOT_ALLOWED);

            round.status = RoundStatus.Active;
        }

        mapping(address => Step[]) playersMoved;
        Step[]  steps;
        Move    move;

        if(roundMoves.exists(roundId)) {
            //  If any player has moved already in this round
            move = roundMoves.fetch(roundId).get();

            if(
                (move.expiresAt < block.timestamp) ||                   //  If move has expired
                (move.playerSteps.keys().length == round.maxPlayers)    //  or all players have moved
            ) {
                move = Move(block.timestamp + round.moveDuration, playersMoved);
            }
        } else {
            move = Move(block.timestamp + round.moveDuration, playersMoved);
        }

        //  Check that player hasn't moved yet
        for(address _player : move.playerSteps.keys()) {
            require(!(_player == player), BaseErrorCodes.NOT_ALLOWED);
        }

        move.playerSteps[player] = steps;

        rnd.shuffle();
        uint16 diceVal = rnd.next(6) + 1;

        emit DiceRolled(player, dice);

        Location    curLocation;
        Location    prevLocation;
        uint16      curCell = playerCell[player];
        uint16      newCell = curCell + diceVal;
        int16       boardOverflow = int16(board.columns) * int16(board.rows) - int16(newCell);
        uint16      x;
        uint16      y;

        prevLocation = Location(curCell, _getCoordinate(curCell));
        curLocation  = Location(newCell, _getCoordinate(newCell));

        if(boardOverflow < 0) {
            newCell = uint16(int16(board.columns * board.rows) + boardOverflow);
            curLocation  = Location(newCell, _getCoordinate(newCell));
        } else if (boardOverflow == 0) {
            //  Player has won
            rounds[roundId].status = RoundStatus.Finished;
            rounds[roundId].winner = player;
            move.playerSteps[player].push(Step(prevLocation, curLocation));
            roundMoves[roundId] = move;

            emit RoundFinished(address(this), roundId, player);
            return {value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false} (diceVal, _getCoordinate(newCell));
        }

        move.playerSteps[player].push(Step(prevLocation, curLocation));

        x = curLocation.coordinate.x;
        y = curLocation.coordinate.y;

        bool flag;
        while(!flag) {
            (uint16 _x, uint16 _y) = _checkContinuation(player, x, y);
            if(_x == x && _y == y) {
                flag = true;
            } else {
                x = _x;
                y = _y;

                prevLocation = curLocation;
                curLocation = Location(_getCell(x, y), Coordinate(x, y));
                move.playerSteps[player].push(Step(prevLocation, curLocation));
                emit PlayerMoved(address(this), roundId, player, prevLocation, curLocation);
            }
        }

        newCell = _getCell(x, y);
        playerCell[player] = newCell;
        roundMoves[roundId] = move;

        return {value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false} (diceVal, Coordinate(x, y));
    }

    /**
        Allows the winner to claim the prize.

        @param  roundId     Round identifier
    */
    function claim(uint64 roundId) external override cashback {
        //  Check if round exists
        require(rounds.exists(roundId), BaseErrorCodes.ITEM_NOT_FOUND);
        Round round = rounds[roundId];

        //  If prize fund is empty, no sense to trigger transaction and spend money
        require(round.prizeFund > 0, BaseErrorCodes.NOTHING_TO_PAY);

        //  Check that the balance is sufficient
        require(address(this).balance > round.prizeFund + Utils.CONTRACT_MIN_BALANCE + msg.value, BaseErrorCodes.NOT_ENOUGH_BALANCE);

        //  Reserve the remaining amount to secure other rounds
        tvm.rawReserve(round.prizeFund + msg.value - TX_STORAGE_FEE, 12);    //  Hotfix until tx fee information appears on mainnet
        //tvm.rawReserve(round.prizeFund + msg.value - tx.storageFee, 12);    //  Reserve all but prize fund for this round and message value less storage fee

        //  Check if the round has finished
        require(round.status == RoundStatus.Finished,    BaseErrorCodes.WRONG_STATE);

        //  Check that the caller is the winner
        //  require(round.winner == msg.sender,              BaseErrorCodes.NOT_ALLOWED);

        //  require(address(this).balance > round.prizeFund, BaseErrorCodes.NOT_ENOUGH_BALANCE);

        //  Check that the prize hasn't been claimed already
        require(!round.prizeClaimed,                     BaseErrorCodes.FINISHED);

        //  Transfer the prize to the winner
        round.winner.transfer({value: round.prizeFund, bounce: false, flag: MsgFlag.SENDER_PAYS_FEES});

        //  Save the status
        rounds[roundId].prizeClaimed = true;

        emit PrizeClaimed(address(this), roundId, round.winner);
    }

    /**
        Returns the generated board

        @return _board      Board object
        @return _redBeams   Array of red portal locations
        @return _blueBeams  Array of blue portal locations
    */
    function getBoard()
        external
        view
        responsible
        override
    returns (Board _board, Path[] _redBeams, Path[] _blueBeams) {
        return {value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false} (board, redBeams, blueBeams);
    }

    function getRoundLatestMove(uint64 roundId) external view responsible override returns (optional(Move) move) {
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} (roundMoves.fetch(roundId));
    }

    function getRound(uint64 roundId) external view responsible override returns (optional(Round) round) {
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} rounds.fetch(roundId);
    }

    function getRounds(optional(RoundStatus) status) external view responsible override returns (Round[] _rounds) {
        if(!status.hasValue()) return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} rounds.values();

        Round[] result;
        RoundStatus rs = status.get();
        for(Round round : rounds.values()) {
            if(round.status == rs) result.push(round);
        }

        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} result;
    }

    function _checkContinuation(address player, uint16 x, uint16 y) internal view returns (uint16 _x, uint16 _y) {
        _x = x;
        _y = y;

        for(Path redBeam : redBeams) {
            if(redBeam.from.x == x && redBeam.from.y == y) {
                _x = redBeam.to.x;
                _y = redBeam.to.y;

                emit PathFound(player, redBeam);
            }
        }

        for(Path blueBeam : blueBeams) {
            if(blueBeam.from.x == x && blueBeam.from.y == y) {
                _x = blueBeam.to.x;
                _y = blueBeam.to.y;

                emit PathFound(player, blueBeam);
            }
        }

        return (_x, _y);
    }

    function _getCell(uint16 x, uint16 y) private view returns (uint16 cell) {
        bool rtl = (y % 2 == 0);
        if (rtl) x = board.columns - x + 1;
        return ((y - 1) * board.columns + x);
    }

    function _getCoordinate(uint16 cell) private view returns (Coordinate) {
        if(cell == 0) return Coordinate(0, 0);

        uint16 y = (cell - 1) / board.columns + 1;
        uint16 x = cell - (y - 1) * board.columns;

        bool rtl = (y % 2 == 0);
        if (rtl) {
            x = board.columns - x + 1;
        }

        return Coordinate(x, y);
    }

    function _getPath(PathType pathType) private view returns (Path path) {
        Coordinate head;
        Coordinate tail;

        uint16 headCell;
        uint16 tailCell;

        bool flag;
        while(!flag) {
            head.x = rnd.next(board.columns) + 1;
            head.y = rnd.next(board.rows - 1) + 2;              //  Head cannot happen on the first row
            headCell = _getCell(head.x, head.y);

            flag =  !(head.y == board.rows && head.x == 1) &&   //  Head cannot be on the final cell
                    !cells[headCell].hasValue();                //  The cell cannot be occupied
        }

        flag = false;
        while(!flag) {
            tail.x = rnd.next(board.columns) + 1;
            tail.y = rnd.next(head.y - 2) + 1;                  //  Tail must be lower than head
            tailCell = _getCell(tail.x, tail.y);
            flag = !cells[tailCell].hasValue();

            if(pathType == PathType.BlueBeam) {
                flag = flag && !(tailCell == 1);                //  BlueBeam cannot happen on the first cell
            }
        }

        Path result;
        if(pathType == PathType.RedBeam) {
            result = Path(head, tail, pathType);
        } else {
            result = Path(tail, head, pathType);
        }

        return result;
    }

    function _checkBoardInitialized() private {
        if((redBeams.length == redBeamsNumber) && (blueBeams.length == blueBeamsNumber)) {
            boardInitialized = true;
            emit BoardGenerated(board, redBeams, blueBeams);
        }
    }

    /**
        Gets a total of specific round reserves: entrance fees, prize and player jackpot accrual

        @param  roundId         Round identifier
        @return totalReserves   Sum of all reserves
    */
    function getRoundReserves(uint64 roundId) public view returns (uint128 totalReserves) {
        require(rounds.exists(roundId), BaseErrorCodes.ITEM_NOT_FOUND);
        require(boardTreasury.roundTreasury.exists(roundId), BaseErrorCodes.ITEM_NOT_FOUND);

        RoundTreasury treasury = boardTreasury.roundTreasury[roundId];
        totalReserves = treasury.entranceFee + treasury.prize;
        for(( , uint128 pj) : treasury.playerJackpot) {
            totalReserves += pj;
        }

        return totalReserves;
    }

    /**
        Gets a total of all reserves per the board, including the jackpot fund, rakes and round reserves

        @return totalReserves   Total reserves
    */
    function getBoardReserves() public view returns(uint128 totalReserves) {
        totalReserves = boardTreasury.jackpot + boardTreasury.rakes;

        for((uint64 rid, ) : boardTreasury.roundTreasury) {
            ( , uint128 roundReserves) = getRoundReserves(rid);
            totalReserves += roundReserves;
        }

        return totalReserves;
    }

}
