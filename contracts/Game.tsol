// SPDX-License-Identifier: UNLICENSED
pragma ever-solidity >= 0.62.0;
//pragma AbiHeader pubkey;

import "./interfaces/IGame.tsol";
import "./abstracts/Ownable.tsol";
import "./abstracts/Cashback.tsol";
import "./libraries/Gas.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";

contract Game is IGame, Ownable, Cashback {
    uint64  public static nonce;

    uint64  private MAX_ROUND_DURATION_MS_DEFAULT = 30 * 60 * 1000; //  30 minutes
    uint64  private MOVE_DURATION_MS_DEFAULT  = 60_000;         //  1 minute

    mapping(uint64 => Round) public rounds;
    uint8   public maxPlayers = 4;
    uint64  public maxRoundDurationMs = MAX_ROUND_DURATION_MS_DEFAULT;
    uint64  public maxMoveDurationMs = MOVE_DURATION_MS_DEFAULT;
    Board   public board;
    Path[]  snakes;
    Path[]  ladders;
    bool    public boardInitialized;
    uint    public seed;
    uint128 public prizeFundPerRound;
    uint128 public entryStake;
    uint8   public maxSnakes;
    uint8   public maxLadders;

    mapping(address => uint64)       playerRound;
    mapping(uint64 => address[])     roundPlayers;
    mapping(uint64 => Move)          roundMoves;
    mapping(address => uint8)        playerCell;
    mapping(uint8 => optional(Path)) cells;

    constructor(address owner, uint8 size) public {
        require(size == 8 || size == 10 || size == 12, BaseErrorCodes.NOT_ALLOWED);

        tvm.accept();
        board = Board(size, size);

        _initOwnable(owner);
    }

    function generateBoard(uint _seed, uint8 _maxSnakes, uint8 _maxLadders)
        external
        override
        onlyOwner
        reservable
        cashback
    {
        require(!boardInitialized, BaseErrorCodes.ITEM_EXISTS);
        require(_maxSnakes <= (board.rows - 2), BaseErrorCodes.VALUE_TOO_BIG);
        require(_maxLadders <= (board.rows - 2), BaseErrorCodes.VALUE_TOO_BIG);

        maxSnakes = _maxSnakes;
        maxLadders = _maxLadders;

        seed = _seed;
        rnd.setSeed(seed);
        rnd.shuffle();

        uint8 headCell;
        uint8 tailCell;

        for(uint8 i = 0; i < maxSnakes; i++) {
            Path snake = _getPath(PathType.Snake);
            headCell = _getCell(snake.from.x, snake.from.y);
            tailCell = _getCell(snake.to.x, snake.to.y);
            cells[headCell] = snake;
            cells[tailCell] = snake;
            snakes.push(snake);
        }

        for(uint8 i = 0; i < maxLadders; i++) {
            Path ladder = _getPath(PathType.Ladder);
            tailCell = _getCell(ladder.from.x, ladder.from.y);
            headCell = _getCell(ladder.to.x, ladder.to.y);
            cells[headCell] = ladder;
            cells[tailCell] = ladder;
            ladders.push(ladder);
        }

        boardInitialized = true;

        emit BoardGenerated(board, snakes, ladders);
    }

    function getBoard()
        external
        view
        responsible
        override
    returns (Board _board, Path[] _snakes, Path[] _ladders) {
        return {value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false} (board, snakes, ladders);
    }

    function roll()
        external
        responsible
        override
    returns (uint8 dice, Coordinate newPosition) {
        address player = msg.sender;
        require(playerRound.exists(player), BaseErrorCodes.NOT_ALLOWED);
        require(playerCell.exists(player), BaseErrorCodes.ITEM_NOT_FOUND);

        uint64 roundId = playerRound[player];
        if(!rounds.exists(roundId)) {
            delete playerRound[player];
            revert(BaseErrorCodes.ITEM_NOT_FOUND);
        }

        Round round = rounds[roundId];
        require(round.status != RoundStatus.Finished, BaseErrorCodes.NOT_ALLOWED);
        if(round.validUntil <= block.timestamp) {
            rounds[roundId].status = RoundStatus.Expired;
            revert(BaseErrorCodes.TOO_LATE);
        }

        if(round.status == RoundStatus.NotStarted) {
            require(address(this).balance > (Gas.CONTRACT_MIN_BALANCE + round.prizeFund), BaseErrorCodes.NOT_ENOUGH_BALANCE);
            require(roundPlayers.values().length == round.maxPlayers, BaseErrorCodes.NOT_ALLOWED);

            round.status = RoundStatus.Active;
        }

        rnd.shuffle(seed);
        uint8 diceVal = rnd.next(6) + 1;

        uint8   curCell = playerCell[player];
        uint8   newCell = curCell + diceVal;
        uint8   boardOverflow = board.columns * board.rows - newCell;

        if(boardOverflow < 0) {
            newCell = board.columns * board.rows - boardOverflow;
        } else if (boardOverflow == 0) {
            //  Player has won
            rounds[roundId].status = RoundStatus.Finished;
            rounds[roundId].winner = player;
        }

        (uint8 y, uint8 x) = math.divmod(newCell, board.columns);

        bool rtl = (y % 2 == 0);
        if (rtl) {
            x = board.columns - x;
        }

        bool flag;
        while(!flag) {
            (uint8 _x, uint8 _y) = _checkContinuation(player, x, y);
            if(_x == x && _y == y) {
                flag = true;
            } else {
                x = _x;
                y = _y;
            }
        }

        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} (diceVal, Coordinate(x, y));
    }

    function createRound()
        external
        responsible
        override
    returns (Round round) {
        require(boardInitialized, BaseErrorCodes.TOO_EARLY);

        uint64 roundId = block.timestamp;
        require(!rounds.exists(roundId), BaseErrorCodes.ITEM_EXISTS);

        Round newRound = Round(
            roundId,
            roundId + maxRoundDurationMs,
            RoundStatus.NotStarted,
            maxPlayers,
            entryStake,
            prizeFundPerRound,
            false,
            address(0)
        );

        rounds[roundId] = newRound;

        emit RoundCreated(address(this), newRound);

        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} newRound;
    }

    function getRound(uint64 roundId) external view responsible override returns (optional(Round) round) {
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} rounds.fetch(roundId);
    }

    function getRounds() external view responsible override returns (Round[] _rounds) {
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false} rounds.values();
    }

    function setMaxPlayers(uint8 qty) external override onlyOwner reservable cashback {
        uint8 oldVal = maxPlayers;
        maxPlayers = qty;

        emit MaxPlayersUpdated(address(this), oldVal, maxPlayers);
    }

    function setMaxRoundTimeMs(uint64 ms) external override onlyOwner reservable cashback {
        uint64 oldVal = maxRoundDurationMs;
        maxRoundDurationMs = ms;

        emit MaxRoundTimeMsUpdated(address(this), oldVal, maxRoundDurationMs);
    }

    function setPrizeFund(uint128 amount) external override onlyOwner reservable cashback {
        uint128 oldVal = prizeFundPerRound;
        prizeFundPerRound = amount;

        emit PrizeFundUpdated(address(this), oldVal, prizeFundPerRound);
    }

    function setEntryStake(uint128 amount) external override onlyOwner reservable cashback {
        uint128 oldVal = entryStake;
        entryStake = amount;

        emit EntryStakeUpdated(address(this), oldVal, entryStake);
    }

    function joinRound(uint64 roundId)
        external
        responsible
        override
    returns (bool result) {
        require(rounds.exists(roundId), BaseErrorCodes.ITEM_NOT_FOUND);

        address player = msg.sender;
        for(address _player : roundPlayers[roundId]) {
            require(_player != player, BaseErrorCodes.NOTHING_CHANGED);
        }

        if(playerRound.exists(player)) {
            require(playerRound[player] != roundId, BaseErrorCodes.NOTHING_CHANGED);
            uint64 oldRound = playerRound[player];

            require(rounds[oldRound].status == RoundStatus.Finished || rounds[oldRound].status == RoundStatus.Expired, BaseErrorCodes.NOT_ALLOWED);
        }

        playerRound[player] = roundId;
        roundPlayers[roundId].push(player);

        emit RoundJoined(address(this), rounds[roundId], player);

        return {value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS} (true);
    }

    function claim(uint64 roundId) external override reservable cashback {
        require(rounds.exists(roundId), BaseErrorCodes.ITEM_NOT_FOUND);
        Round round = rounds[roundId];

        require(round.status == RoundStatus.Finished, BaseErrorCodes.NOT_ALLOWED);
        require(round.winner == msg.sender, BaseErrorCodes.NOT_ALLOWED);
        require(address(this).balance > (Gas.CONTRACT_MIN_BALANCE + round.prizeFund), BaseErrorCodes.NOT_ENOUGH_BALANCE);
        require(!round.prizeClaimed, BaseErrorCodes.NOT_ALLOWED);

        msg.sender.transfer({value: round.prizeFund, bounce: false});
        rounds[roundId].prizeClaimed = true;

        emit PrizeClaimed(address(this), round, msg.sender);
    }

    function _checkContinuation(address player, uint8 x, uint8 y) internal view returns (uint8 _x, uint8 _y) {
        _x = x;
        _y = y;

        for(Path snake : snakes) {
            if(snake.from.x == x && snake.from.y == y) {
                _x = snake.to.x;
                _y = snake.to.y;

                emit PathFound(player, snake);
            }
        }

        for(Path ladder : ladders) {
            if(ladder.from.x == x && ladder.from.y == y) {
                _x = ladder.to.x;
                _y = ladder.to.y;

                emit PathFound(player, ladder);
            }
        }

        return (_x, _y);
    }

    function _getCell(uint8 x, uint8 y) private view returns (uint8 cell) {
        bool rtl = (y % 2 == 0);
        if (rtl) x = board.columns - x;
        return (y * board.columns + x);
    }

    function _getPath(PathType pathType) private view returns (Path path) {
        Coordinate head;
        Coordinate tail;

        uint8 headCell;
        uint8 tailCell;

        bool flag;
        while(!flag) {
            head.x = rnd.next(board.columns) + 1;
            head.y = rnd.next(board.rows - 1) + 2;              //  Head cannot happen on the first row
            headCell = _getCell(head.x, head.y);

            flag =  !(head.y == board.rows && head.x == 1) &&   //  Head cannot be on the final cell
                    !cells[headCell].hasValue();                //  The cell cannot be occupied
        }

        flag = false;
        while(!flag) {
            tail.x = rnd.next(board.columns) + 1;
            tail.y = rnd.next(head.y - 2) + 1;                  //  Tail must be lower than head
            tailCell = _getCell(tail.x, tail.y);
            flag = !cells[tailCell].hasValue();

            if(pathType == PathType.Ladder) {
                flag = flag && !(tailCell == 1);                //  Ladder cannot happen on the first cell
            }
        }

        Path result;
        if(pathType == PathType.Snake) {
            result = Path(head, tail, pathType);
        } else {
            result = Path(tail, head, pathType);
        }

        return result;
    }

    function _checkBoardInitialized() private {
        if((snakes.length == maxSnakes) && (ladders.length == maxLadders)) {
            boardInitialized = true;
            emit BoardGenerated(board, snakes, ladders);
        }
    }

}
